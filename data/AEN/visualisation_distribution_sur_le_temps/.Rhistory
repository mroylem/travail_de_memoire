library(stringi)
library(packcircles)
library(ggiraph)
library(stringr)
library(ggrepel)
df <- read_excel("DF_inventaire_photos_AEN.xlsx")
# 4.1 Agrégation par fonds
df_bubbles <- df %>%
mutate(across(starts_with("nbre_"), ~ suppressWarnings(as.numeric(.x)))) %>%
group_by(fonds) %>%
summarise(
vol_total = sum(c_across(starts_with("nbre_")), na.rm = TRUE),
type_fonds = dplyr::first(na.omit(as.character(type_fonds))),
permalien  = dplyr::first(na.omit(as.character(permalien))),
.groups = "drop"
) %>%
filter(!is.na(fonds), vol_total > 0) %>%
mutate(
type_fonds = factor(type_fonds, levels = c("privé", "public", "rassemblement thématique", "Privé", "Public", "Rassemblement thématique"))
)
# 4.2 Disposition des cercles (non chevauchants)
# Définition des seuils de taille pour les cercles
size_breaks <- c(20, 50, 100, 500, 1000, 2000, 5000, 10000, 15000)
# Création des classes de taille avec ajustement des tailles
df_bubbles <- df_bubbles %>%
mutate(
# Ajustement non-linéaire des tailles
adjusted_size = case_when(
vol_total > 5000 ~ vol_total * 0.9,    # Réduction des très grands cercles
vol_total < 100 ~ vol_total * 1.3,     # Augmentation plus marquée des très petits cercles
vol_total == 100 ~ vol_total * 1.25,   # Augmentation pour 100
vol_total == 500 ~ vol_total * 1.2,    # Augmentation pour 500
vol_total == 1000 ~ vol_total * 1.15,  # Augmentation pour 1000
TRUE ~ vol_total * 1.1                 # Légère augmentation pour les autres tailles
),
# Application des classes de taille sur les tailles ajustées
vol_size = findInterval(adjusted_size, size_breaks, left.open = TRUE) %>%
{size_breaks[. + 1] %>% replace_na(last(size_breaks))}
)
# Calcul du layout des cercles
layout_cp <- packcircles::circleProgressiveLayout(df_bubbles$vol_size, sizetype = "area")
# Préparation des données pour le tracé
df_bubbles <- bind_cols(
df_bubbles,
layout_cp %>% dplyr::rename(cx = x, cy = y, r = radius)
)
# Création des sommets pour les polygones des cercles
vertices <- packcircles::circleLayoutVertices(layout_cp, npoints = 60, idcol = NULL) %>%
dplyr::mutate(id = as.integer(id))
# Joindre les attributs aux sommets
vertices_full <- vertices %>%
left_join(df_bubbles %>% mutate(id = row_number()), by = "id") %>%
# Champs préparés pour ggiraph: tooltip sans apostrophes non échappées,
# et JS onclick qui ouvre le permalien
mutate(
# Tooltip garanti sans apostrophes (on les retire)
tooltip_safe = paste0(
stringr::str_replace_all(fonds, "'", ""),
"\nTotal: ", scales::comma(vol_total)
),
# Identifiant d'élément interactif sans apostrophes
data_id_safe = stringr::str_replace_all(fonds, "'", ""),
# URL: encoder entièrement pour un href/JS sûr
permalink = as.character(dplyr::coalesce(permalien, "")) %>%
utils::URLencode(reserved = TRUE),
# Indicateur de présence de lien
has_link = permalink != "",
# JS onclick sans aucune apostrophe, uniquement des guillemets doubles échappés
onclick_js = ifelse(
has_link,
paste0("window.open(\\\"", permalink, "\\\",\\\"_blank\\\")"),
NA_character_
),
# Facultatif: indiquer dans le tooltip s'il n'y a pas de lien
tooltip_safe = ifelse(has_link, tooltip_safe, paste0(tooltip_safe, "\n(pas de permalien)"))
)
# Palette des types de fonds (harmonise minuscules/majuscules)
# RColorBrewer Set2 (douce et lisible)
pal3 <- RColorBrewer::brewer.pal(3, "Set2")
pal_fonds <- c(
"privé" = pal3[1], "Privé" = pal3[1],
"public" = pal3[2], "Public" = pal3[2],
"rassemblement thématique" = pal3[3], "Rassemblement thématique" = pal3[3]
)
# Nouveaux seuils pour les tailles de cercles
size_breaks <- c(10, 20, 50, 100, 500, 1000, 3000, 5000, 10000)
# Création d'une échelle personnalisée pour le mapping des tailles
size_mapping <- c(
"10" = 1, "20" = 2, "50" = 3,
"100" = 4, "500" = 5, "1000" = 6,
"3000" = 7, "5000" = 8, "10000" = 9
)
# Création du dataframe pour la légende avec les nouvelles tailles
df_size_leg <- tibble::tibble(size_val = size_breaks)
# 4.3 Rendu statique
p_circlepack <- ggplot(vertices_full) +
geom_polygon(aes(x, y, group = id, fill = type_fonds), colour = "white", linewidth = 0.3) +
# Couche factice (invisible) pour générer une légende de tailles
geom_point(
data = df_size_leg,
aes(x = 0, y = 0, size = size_val),
inherit.aes = FALSE,
alpha = 0
) +
coord_equal() +
scale_fill_manual(values = pal_fonds,
na.value = "#B0B0B0",
name = "Type de fonds") +
# Ajustement de l'espacement des légendes
theme(legend.spacing.y = unit(5, "pt")) +
scale_size_area(name = "Taille des fonds",
breaks = size_breaks,
labels = scales::comma(size_breaks),
max_size = 20,
guide = guide_legend(
title.position = "top",
title.theme = element_text(face = "bold", size = 12),
override.aes = list(alpha = 1, colour = "#555555")
)
) +
# Mise en forme du graphique
theme_void(base_size = 12) +
theme(
text = element_text(family = "sans"),
plot.margin = margin(15, 15, 15, 25),
plot.title.position = "plot",
plot.title = element_text(face = "bold", size = 16, hjust = 0, margin = margin(b = 5, l = 5)),
plot.subtitle = element_text(size = 12, hjust = 0, margin = margin(b = 10, l = 5)),
plot.caption = element_text(size = 9, colour = "#555555"),
# Style de la légende
legend.position = "right",
legend.justification = "left",  # Alignement à gauche
legend.box.margin = margin(0, 0, 0, 0),
legend.key.size = unit(0.7, "lines"),
legend.spacing.y = unit(5, "pt"),
legend.title = element_text(size = 10, face = "bold", hjust = 0, margin = margin(b = 5, l = 0)),
legend.text = element_text(size = 9, hjust = 0),
legend.box = "vertical"
) +
labs(
title = "Projection des fonds photographiques selon leur volume et leur statut",
subtitle = "Chaque cercle représente le volume photographique conservé dans un fonds.",
caption = "Données : Inventaire des fonds photographiques — Archives de l'État de Neuchâtel"
) +
guides(
fill = guide_legend(order = 1, title.theme = element_text(face = "bold")),
size = guide_legend(order = 2, title.theme = element_text(face = "bold"),
override.aes = list(alpha = 1, colour = "#555555"))
)
# Libellés intégrés dans les cercles (pas de fond, pas de contour), sans troncature
df_labels <- df_bubbles %>%
mutate(
# Application du nouveau mapping des tailles
size_mapped = as.numeric(as.character(cut(vol_total,
breaks = c(0, size_breaks[-1], Inf),
labels = size_breaks,
right = TRUE))),
# Ajustement des rayons pour correspondre aux nouvelles tailles
r = sqrt(size_mapped / max(size_breaks, na.rm = TRUE)) * 1.2,  # Augmentation de l'échelle des rayons
label = fonds,
# Taille du texte en fonction du rayon (plus grand cercle => texte plus grand)
size_pt = pmin(8.0, pmax(3.6, 3.0 + 6.0 * (r / max(r, na.rm = TRUE))))
) %>%
filter(vol_total >= 80)  # Afficher les labels à partir de 80 unités
p_circlepack <- p_circlepack +
geom_text(
data = df_labels,
aes(x = cx, y = cy, label = label),
inherit.aes = FALSE,
size = df_labels$size_pt / ggplot2::.pt,
colour = "#0b0b0b",
fontface = "bold",
lineheight = 0.95
)
# 4.4 Sauvegarde du rendu statique (SVG)
ggsave("Projection_fonds_circle_packing.svg",
plot = p_circlepack,
width = 10,   # Largeur en pouces
height = 8,   # Hauteur en pouces
dpi = 300,    # Haute résolution
bg = "white"  # Fond blanc
)
# 4.5 Sauvegarde du rendu statique (JPEG - pour compatibilité)
ggsave("Projection_fonds_circle_packing.jpeg",
plot = p_circlepack,
width = 10,   # Largeur en pouces
height = 8,   # Hauteur en pouces
dpi = 300,    # Haute résolution
bg = "white"  # Fond blanc
)
setwd("C:/Users/raiku/Documents/Stage/Viusalisation distribution sur le temps")
library(ggplot2)
library(dplyr)
library(scales)
library(tidyverse)
library(readxl)
library(RColorBrewer)
library(stringr)
library(tidyr)
library(grid)
library(stringi)
df <- read_excel("DF_inventaire_photos_AEN.xlsx")
# ===== Préparation minimale: point médian (1880–1995) + palette + échelle Y =====
df_mid <- df %>%
mutate(
date_min = as.numeric(date_min),
date_max = as.numeric(date_max),
year     = floor((date_min + date_max)/2)
) %>%
filter(!is.na(year), year >= 1880, year <= 1995)
# Échelle Y: graduations "pretty" et libellés complets
y_breaks_fun <- scales::breaks_extended(n = 6)
y_labels_fun <- scales::label_number(
accuracy = 1,
big.mark = " "
)
# ===== Variante test: tranches de 10 ans =====
breaks_10 <- seq(1880, 2000, by = 10)
labels_10 <- paste0(breaks_10[-length(breaks_10)], "–", breaks_10[-1] - 1)
df_supports_10 <- df_mid %>%
mutate(bin_10y = cut(year, breaks = breaks_10, right = FALSE, labels = labels_10)) %>%
mutate(
nbre_photographie      = suppressWarnings(as.numeric(nbre_photographie)),
nbre_carte_postale     = suppressWarnings(as.numeric(nbre_carte_postale)),
nbre_negatif           = suppressWarnings(as.numeric(nbre_negatif)),
nbre_planches_contact  = suppressWarnings(as.numeric(nbre_planches_contact)),
nbre_diapositive       = suppressWarnings(as.numeric(nbre_diapositive)),
nbre_plaque_de_verre   = suppressWarnings(as.numeric(nbre_plaque_de_verre)),
nbre_daguerrotype      = suppressWarnings(as.numeric(nbre_daguerrotype))
) %>%
select(bin_10y, nbre_photographie, nbre_carte_postale, nbre_negatif,
nbre_planches_contact, nbre_diapositive, nbre_plaque_de_verre, nbre_daguerrotype) %>%
pivot_longer(cols = starts_with("nbre_"), names_to = "support_col", values_to = "n") %>%
mutate(n = replace_na(n, 0)) %>%
mutate(Support = case_when(
support_col == "nbre_photographie"      ~ "Tirage positif sur papier",
support_col == "nbre_carte_postale"     ~ "Carte postale photographique",
support_col == "nbre_negatif"           ~ "Négatif souple (film)",
support_col == "nbre_planches_contact"  ~ "Planche-contact",
support_col == "nbre_diapositive"       ~ "Diapositive",
support_col == "nbre_plaque_de_verre"   ~ "Négatif sur plaque de verre",
support_col == "nbre_daguerrotype"      ~ "Daguerréotype",
TRUE ~ NA_character_
)) %>%
# Ordre: Positifs d'abord, puis Négatifs & assimilés (contrôle empilement et légende)
mutate(Support = factor(
Support,
levels = c(
"Tirage positif sur papier", "Carte postale photographique",
"Planche-contact", "Négatif souple (film)", "Négatif sur plaque de verre", "Daguerréotype", "Diapositive"
)
)) %>%
filter(!is.na(bin_10y), !is.na(Support)) %>%
group_by(bin_10y, Support) %>%
summarise(n = sum(n, na.rm = TRUE), .groups = "drop") %>%
mutate(bin_10y = factor(bin_10y, levels = labels_10)) %>%
group_by(bin_10y) %>%
mutate(
total = sum(n, na.rm = TRUE),
prop = ifelse(total > 0, n / total, 0),
label_ok = prop >= 0.20,
label_txt = scales::label_number(accuracy = 1, big.mark = " ")(n)
) %>%
ungroup()
# Étendue Y: inclure exactement le maximum total par période et forcer une graduation au sommet
y_max_10 <- df_supports_10 %>%
group_by(bin_10y) %>% summarise(total = sum(n, na.rm = TRUE), .groups = "drop") %>%
summarise(max_total = max(total, na.rm = TRUE)) %>% pull(max_total)
y_breaks_10 <- y_breaks_fun(c(0, y_max_10))
if (length(y_breaks_10) == 0 || max(y_breaks_10) < y_max_10) {
y_breaks_10 <- sort(unique(c(y_breaks_10, y_max_10)))
}
# Totaux par décennie (pour affichage au-dessus des barres)
df_totals_10 <- df_supports_10 %>%
group_by(bin_10y) %>%
summarise(total = sum(n, na.rm = TRUE), .groups = "drop") %>%
mutate(label_total = scales::label_number(accuracy = 1, big.mark = " ")(total))
# Palette Set2 avec inversion de couleurs entre "Planche-contact" et "Négatif souple (film)"
pal_set2 <- RColorBrewer::brewer.pal(7, "Set2")
# Ordre des catégories tel que défini dans les breaks plus bas
cats_support <- c(
"Tirage positif sur papier", "Carte postale photographique",
"Planche-contact", "Négatif souple (film)", "Négatif sur plaque de verre", "Daguerréotype", "Diapositive"
)
# Attribution par défaut (positionnelle)
pal_support <- setNames(pal_set2[seq_along(cats_support)], cats_support)
# Échanger les couleurs des deux catégories demandées
pc_col <- pal_support[["Planche-contact"]]
neg_col <- pal_support[["Négatif souple (film)"]]
pal_support[["Planche-contact"]] <- neg_col
pal_support[["Négatif souple (film)"]] <- pc_col
p_support_bar_10_mid <- ggplot(df_supports_10, aes(x = bin_10y, y = n, fill = Support)) +
geom_col(width = 0.9, color = "white", linewidth = 0.2) +
geom_text(
data = df_totals_10,
aes(x = bin_10y, y = total, label = label_total),
inherit.aes = FALSE,
vjust = -0.4,
size = 3.2
) +
scale_fill_manual(
name = "Support",
values = pal_support,
breaks = cats_support
) +
scale_y_continuous(
breaks = y_breaks_10,
labels = y_labels_fun,
expand = expansion(mult = c(0, 0.06))
) +
labs(
title    = "Types de support dans les fonds photographiques (1880–1995)",
subtitle = "Point médian par fonds, regroupé par tranche décennales (10 ans). Chaque fonds est positionné sur sa date médiane de production, faute de dates précises pour chaque image.",
x        = "Période (tranches de 10 ans)",
y        = "Nombre de photos par support",
caption  = "Données : Inventaire des fonds photographiques - Archives de l'État de Neuchâtel"
) +
theme_minimal(base_size = 12) +
theme(
plot.title    = element_text(face = "bold", size = 14),
plot.subtitle = element_text(size = 11),
plot.caption  = element_text(size = 8, hjust = 1, colour = "grey30", lineheight = 0.95, margin = margin(t = 4)),
plot.caption.position = "plot",
legend.position = "right",
legend.title    = element_text(face = "bold"),
axis.title.x = element_text(margin = margin(t = 12))
)
#SAVE JPEG
ggsave("distribution_types_supports_1880_1995_10ans_median.jpeg",
p_support_bar_10_mid, width = 14, height = 7, dpi = 300)
#SAVE SVG
ggsave("distribution_types_supports_1880_1995_10ans_median.svg",
p_support_bar_10_mid, width = 14, height = 7, dpi = 300)
# Préparation: bornage des dates et calcul du volume par ligne
df_fonds_base <- df %>%
mutate(
fonds = stringr::str_squish(as.character(fonds)),
date_min = suppressWarnings(as.numeric(date_min)),
date_max = suppressWarnings(as.numeric(date_max))
) %>%
# ne pas exclure si un seul des deux est présent
mutate(
date_min_eff = dplyr::coalesce(date_min, date_max),
date_max_eff = dplyr::coalesce(date_max, date_min)
) %>%
# bornage après imputation
mutate(
date_min_b = pmax(1850, pmin(2005, date_min_eff)),
date_max_b = pmax(1850, pmin(2005, date_max_eff)),
year_mid   = floor((date_min_b + date_max_b) / 2)
)
# Colorimétrie simplifiée à 3 classes (normalisation des accents et espaces)
df_fonds_base <- df_fonds_base %>%
mutate(
color_raw0 = tolower(coalesce(as.character(colorimetrie), "")),
# enlever les accents (ex: "sépia" -> "sepia"), compresser espaces
color_raw  = stringi::stri_trans_general(stringr::str_squish(color_raw0), "Latin-ASCII")
) %>%
mutate(colorimetrie_3 = case_when(
str_detect(color_raw, "sepia") ~ "Sépia",
str_detect(color_raw, "noir|noire|blanc|blanche|n&b|\bnb\b|b/w|\bbw\b") ~ "Noir et blanc",
str_detect(color_raw, "couleur|couleurs|color|chrom") ~ "Couleur",
str_detect(color_raw, "negatif|negatives|negatif(s)?|n[eé]gatif") ~ "Négatif",
TRUE ~ NA_character_
))
# Volume par ligne = somme des colonnes nbre_* (vectorisé, sûr numériquement)
df_fonds_base <- df_fonds_base %>%
mutate(across(starts_with("nbre_"), ~ suppressWarnings(as.numeric(.x))))
# Utiliser rowSums pour garantir un vecteur numérique (évite les colonnes liste et les erreurs de type)
nbre_cols <- df_fonds_base %>% select(starts_with("nbre_"))
df_fonds_base$volume_ligne <- if (ncol(nbre_cols) > 0) rowSums(nbre_cols, na.rm = TRUE) else 0
# Agrégation par fonds (présence regex par fonds, SANS pondération au niveau ligne)
df_fonds_agg <- df_fonds_base %>%
group_by(fonds) %>%
summarise(
start = suppressWarnings(min(date_min_b, na.rm = TRUE)),
end   = suppressWarnings(max(date_max_b, na.rm = TRUE)),
year_mid   = suppressWarnings(floor(median(year_mid, na.rm = TRUE))),
vol_total  = sum(volume_ligne, na.rm = TRUE),
has_nb  = any(str_detect(color_raw, "noir|noire|blanc|blanche|n&b|\bnb\b|b/w|\bbw\b"), na.rm = TRUE),
has_sep = any(str_detect(color_raw, "sepia|s[eé]pia"), na.rm = TRUE),
has_col = any(str_detect(color_raw, "couleur|couleurs|color|chrom"), na.rm = TRUE),
sum_photographie      = sum(suppressWarnings(as.numeric(nbre_photographie)), na.rm = TRUE),
sum_carte_postale     = sum(suppressWarnings(as.numeric(nbre_carte_postale)), na.rm = TRUE),
sum_negatif           = sum(suppressWarnings(as.numeric(nbre_negatif)), na.rm = TRUE),
sum_planches_contact  = sum(suppressWarnings(as.numeric(nbre_planches_contact)), na.rm = TRUE),
sum_diapositive       = sum(suppressWarnings(as.numeric(nbre_diapositive)), na.rm = TRUE),
sum_plaque_de_verre   = sum(suppressWarnings(as.numeric(nbre_plaque_de_verre)), na.rm = TRUE),
sum_daguerrotype      = sum(suppressWarnings(as.numeric(nbre_daguerrotype)), na.rm = TRUE),
.groups = "drop"
) %>%
mutate(
neg_units = sum_negatif + sum_plaque_de_verre + sum_daguerrotype,
other_units = sum_photographie + sum_carte_postale + sum_diapositive + sum_planches_contact,
has_neg_excl = (neg_units > 0) & (other_units == 0)
) %>%
# Déterminer la combinaison une seule fois ici
mutate(
combo = case_when(
has_neg_excl ~ "Négatif uniquement",
has_nb & !has_sep & !has_col ~ "Noir et blanc uniquement",
!has_nb & has_sep & !has_col ~ "Sépia uniquement",
!has_nb & !has_sep & has_col ~ "Couleur uniquement",
has_nb & has_sep & !has_col ~ "Noir et blanc, Sépia",
has_nb & !has_sep & has_col ~ "Noir et blanc, Couleur",
# Sépia, Couleur a été retiré (pas présent dans tes données)
has_nb & has_sep & has_col ~ "Noir et blanc, Sépia, Couleur",
TRUE ~ "Non renseigné"
)
) %>%
mutate(combo = stringr::str_squish(combo)) %>%
# bornes finales et suppression des fonds sans intervalle
mutate(
start = pmax(1850, pmin(2005, start)),
end   = pmax(1850, pmin(2005, end))
) %>%
filter(!is.infinite(start), !is.infinite(end), !is.na(start), !is.na(end), end >= start)
# Inclure tous les fonds et ordonner par médiane
df_fonds_top <- df_fonds_agg %>%
arrange(fonds) %>%
mutate(
# ordre alphabétique de haut en bas
fonds_ord = factor(fonds, levels = rev(sort(unique(fonds))))
)
levels_combo <- c(
"Négatif uniquement",
"Noir et blanc uniquement",
"Sépia uniquement",
"Couleur uniquement",
"Noir et blanc, Sépia",
"Noir et blanc, Couleur",
"Noir et blanc, Sépia, Couleur",
"Non renseigné"
)
df_fonds_top <- df_fonds_top %>% mutate(combo = factor(combo, levels = levels_combo))
# Palette manuelle (8 catégories, teintes distinctes et lisibles)
pal_combo <- c(
"Négatif uniquement"              = "#7F7F7F",  # gris
"Noir et blanc uniquement"        = "#90be6d",  # vert
"Sépia uniquement"                = "#ffd670",  # jaune pastel
"Couleur uniquement"              = "#70d6ff",  # bleu pastel
"Noir et blanc, Sépia"            = "#f3722c",  # orange soutenu
"Noir et blanc, Couleur"          = "#9d4edd",  # violet/bleu soutenu
"Noir et blanc, Sépia, Couleur"   = "#dd1d20",  # rouge
"Non renseigné"                   = "#B0B0B0"   # gris clair
)
p_frise_fonds <- ggplot(df_fonds_top) +
geom_segment(aes(x = start, xend = end, y = fonds_ord, yend = fonds_ord, color = combo), linewidth = 2) +
scale_color_manual(name = "Colorimétrie présente :", values = pal_combo, na.translate = FALSE, breaks = levels_combo, drop = TRUE) +
scale_x_continuous(limits = c(1850, 2005), breaks = seq(1850, 2005, by = 15)) +
labs(
title = "Distribution chronologique des fonds photographiques et de leur colorimétrie",
subtitle = "Chaque segment représente l'intervalle de dates couvert par un fonds ; la couleur indique la ou les colorimétries identifiées.",
x = "Année",
y = "Fonds",
caption = "Données : Inventaire des fonds photographiques - Archives de l'État de Neuchâtel"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0),
plot.subtitle = element_text(size = 11),
plot.caption = element_text(size = 8, colour = "grey30"),
legend.title = element_text(face = "bold"),
legend.position = "bottom",
legend.justification = "left",
legend.box = "horizontal",
legend.box.just = "left",
legend.box.margin = margin(t = 0, b = 0, l = 0, r = 0),
legend.text = element_text(size = 9),
legend.key.width = unit(10, "pt"),
legend.key.height = unit(10, "pt"),
axis.text.y = element_text(size = 8),
axis.title.x = element_text(margin = margin(t = 12)),
axis.title.y = element_text(margin = margin(r = 2)),
plot.margin = margin(t = 10, r = 20, b = 10, l = 10)
) +
guides(color = guide_legend(nrow = 1, byrow = TRUE, title.position = "top", title.hjust = 0, label.hjust = 0, override.aes = list(linewidth = 3))) +
coord_cartesian(xlim = c(1850, 2005), clip = "off")
#SAVE JPEG
ggsave("frise_fonds_1850_2005_combinaisons_colorimetries.jpeg", p_frise_fonds, width = 18, height = 10, dpi = 300)
#SAVE SVG
ggsave("frise_fonds_1850_2005_combinaisons_colorimetries.svg", p_frise_fonds, width = 18, height = 10, dpi = 300)
p_frise_fonds_simple <- ggplot(df_fonds_top) +
geom_segment(aes(x = start, xend = end, y = fonds_ord, yend = fonds_ord),
linewidth = 2.4, color = "#413f3f") +
scale_x_continuous(limits = c(1850, 2005), breaks = seq(1850, 2005, by = 10)) +
labs(
title = "Répartition dans le temps des fonds photographiques",
subtitle = "Chaque segment représente l'intervalle de dates couvert par un fonds.",
x = "Année",
y = "Fonds",
caption = "Données : Inventaire des fonds photographiques - Archives de l'État de Neuchâtel"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0),
plot.subtitle = element_text(size = 11),
plot.caption = element_text(size = 8, colour = "grey30"),
legend.position = "none",
axis.text.y = element_text(size = 8),
axis.title.x = element_text(margin = margin(t = 12)),
axis.title.y = element_text(margin = margin(r = 2)),
plot.margin = margin(t = 10, r = 20, b = 10, l = 10),
panel.grid.major = element_line(colour = "#E0E0E0"),  # ~ grey88
panel.grid.minor = element_line(colour = "#EBEBEB")   # ~ grey92
) +
coord_cartesian(xlim = c(1850, 2005), clip = "off")
ggsave("frise_fonds_1850_2005_simple.jpeg", p_frise_fonds_simple, width = 18, height = 10, dpi = 300)
#SAVE JPEG
ggsave("frise_fonds_1850_2005_simple.jpeg", p_frise_fonds_simple, width = 18, height = 10, dpi = 300)
#SAVE SVG
ggsave("frise_fonds_1850_2005_simple.svg", p_frise_fonds_simple, width = 18, height = 10, dpi = 300)
